#!/bin/bash
# tools/add-peer-key.sh
# Add a peer's public key and regenerate wg0.conf using ../config.yaml

set -euo pipefail

# ---------- CLI ----------
CONFIG_FILE_DEFAULT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/../config.yaml"
CONFIG_FILE="$CONFIG_FILE_DEFAULT"
PEER_NAME=""
PUBLIC_KEY=""

usage() {
  echo "Usage: $0 [-c|--config <path/to/config.yaml>] <peer-name> <public-key>"
  echo "Example: sudo $0 dev-02 'LgvMuKX3vV3NGXurnIDclJUeaYw1zuG4dsuIkqYDghs='"
  exit 1
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -c|--config) CONFIG_FILE="$2"; shift 2 ;;
    -h|--help) usage ;;
    *) 
      if [[ -z "${PEER_NAME:-}" ]]; then PEER_NAME="$1"
      elif [[ -z "${PUBLIC_KEY:-}" ]]; then PUBLIC_KEY="$1"
      else usage; fi
      shift
      ;;
  esac
done

[[ -n "${PEER_NAME:-}" && -n "${PUBLIC_KEY:-}" ]] || usage

# ---------- Colors & logging ----------
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; NC='\033[0m'
log()         { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $*"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $*"; }
log_error()   { echo -e "${RED}[ERROR]${NC} $*"; }

# ---------- Root check ----------
if [[ $EUID -ne 0 ]]; then
  log_error "This script must be run as root (use sudo)."
  exit 1
fi

# ---------- Config checks ----------
if [[ ! -f "$CONFIG_FILE" ]]; then
  log_error "Config file not found at: $CONFIG_FILE"
  exit 1
fi

# ---------- Helpers ----------
have_yq=false
if command -v yq >/dev/null 2>&1; then have_yq=true; fi

cfg_get() {
  local jqpath="$1" default="${2:-}"
  if $have_yq; then
    local val
    # yq returns "null" for missing, normalize to empty
    val="$(yq eval "$jqpath // \"\"" "$CONFIG_FILE" 2>/dev/null || echo "")"
    [[ -n "$val" ]] && echo "$val" || echo "$default"
  else
    # very light fallback parsing; best effort for your known keys
    local key="${jqpath##*.}"
    local line
    line="$(grep -E "^[[:space:]]*$key:" "$CONFIG_FILE" | head -1 || true)"
    if [[ -n "$line" ]]; then
      echo "$line" | sed 's/.*:[[:space:]]*//' | sed 's/^"//' | sed 's/"$//' | tr -d "'" 
    else
      echo "$default"
    fi
  fi
}

# Peer-specific read: address & keepalive by name
peer_field_by_name() {
  local name="$1" field="$2"
  if $have_yq; then
    yq eval ".peers[] | select(.name == \"$name\") | .$field // \"\"" "$CONFIG_FILE" 2>/dev/null || echo ""
  else
    # Fallback awk to scan the peer block
    awk -v n="$name" -v f="$field" '
      $0 ~ /^[[:space:]]*-[[:space:]]*name:[[:space:]]*/ {
        inblk=0
        if(index($0,n)>0) { inblk=1 }
      }
      inblk && $0 ~ f":" {
        gsub(/.*: */,"",$0); gsub(/^"|"$/,"",$0); gsub(/'"'"'/,"",$0); print; exit
      }
    ' "$CONFIG_FILE"
  fi
}

# ---------- Paths & values ----------
PEERS_DIR="$(cfg_get '.vps.wireguard.peers_dir' '/etc/wireguard/peers')"
VPS_PRIVATE_KEY_PATH="$(cfg_get '.vps.wireguard.private_key_path' '/etc/wireguard/vps-private.key')"
VPS_ADDRESS="$(cfg_get '.vps.wireguard.vps_address' '10.8.0.1/24')"
LISTEN_PORT="$(cfg_get '.vps.wireguard.listen_port' '51820')"

mkdir -p "$PEERS_DIR"
chmod 700 "$PEERS_DIR"

# ---------- Save the provided public key ----------
echo "$PUBLIC_KEY" > "$PEERS_DIR/${PEER_NAME}.pub"
chmod 600 "$PEERS_DIR/${PEER_NAME}.pub"
log_success "Added public key for peer: $PEER_NAME → $PEERS_DIR/${PEER_NAME}.pub"

# ---------- Validate VPS private key ----------
if [[ ! -f "$VPS_PRIVATE_KEY_PATH" ]]; then
  log_error "VPS private key not found: $VPS_PRIVATE_KEY_PATH"
  echo "Generate with:"
  echo "  sudo sh -c 'wg genkey | tee $VPS_PRIVATE_KEY_PATH | wg pubkey > /etc/wireguard/vps-public.key'"
  exit 1
fi
VPS_PRIVATE_KEY="$(cat "$VPS_PRIVATE_KEY_PATH")"

# ---------- Build wg0.conf ----------
WG_CONF="/etc/wireguard/wg0.conf"

if [[ -f "$WG_CONF" ]]; then
  cp "$WG_CONF" "/etc/wireguard/wg0.conf.backup.$(date +%Y%m%d_%H%M%S)"
  log "Backed up existing wg0.conf"
fi

cat > "$WG_CONF" <<EOF
# VPS WireGuard Configuration
# Generated by tools/add-peer-key.sh

[Interface]
PrivateKey = $VPS_PRIVATE_KEY
Address    = $VPS_ADDRESS
ListenPort = $LISTEN_PORT
SaveConfig = false

# Enable packet forwarding and NAT
PostUp   = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE

EOF

PEERS_ADDED=0
shopt -s nullglob
for keyfile in "$PEERS_DIR"/*.pub; do
  PK="$(cat "$keyfile")"
  NAME="$(basename "$keyfile" .pub)"

  ADDR="$(peer_field_by_name "$NAME" "address")"
  KA="$(peer_field_by_name "$NAME" "keepalive")"
  [[ -z "$KA" ]] && KA="$(cfg_get '.defaults.wireguard.keepalive' '25')"

  if [[ -z "$ADDR" ]]; then
    log_warning "Skipping peer $NAME: address not found in config.yaml"
    continue
  fi

  cat >> "$WG_CONF" <<EOF

# Peer: $NAME
[Peer]
PublicKey           = $PK
AllowedIPs          = $ADDR
PersistentKeepalive = $KA

EOF
  ((PEERS_ADDED++))
  log_success "Staged peer: $NAME ($ADDR)"
done
shopt -u nullglob

chmod 600 "$WG_CONF"

if (( PEERS_ADDED == 0 )); then
  log_warning "No peers staged in $PEERS_DIR; wg0.conf has only [Interface]."
fi

# ---------- Restart service ----------
log "Restarting WireGuard…"
if systemctl is-active --quiet wg-quick@wg0; then
  systemctl restart wg-quick@wg0
else
  systemctl start wg-quick@wg0
fi
sleep 1

if systemctl is-active --quiet wg-quick@wg0; then
  log_success "WireGuard service is active."
  echo
  log "Current status:"
  wg show wg0 || log_warning "wg show failed"
else
  log_error "WireGuard failed to start. Check: journalctl -u wg-quick@wg0"
  exit 1
fi
