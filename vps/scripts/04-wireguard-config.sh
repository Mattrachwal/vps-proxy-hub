#!/bin/bash
# VPS Setup - WireGuard Configuration
# Generates WireGuard configuration from config.yaml and manages peer connections

set -euo pipefail

# Load utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/utils.sh"

main() {
    log "Starting WireGuard configuration..."
    
    check_root
    check_config
    
    # Generate main WireGuard configuration
    generate_wg_config
    
    # Setup peer management
    setup_peer_management
    
    # Enable and start WireGuard service
    enable_wireguard_service
    
    # Display connection information
    display_connection_info
    
    log_success "WireGuard configuration completed"
}

generate_wg_config() {
    log "Generating WireGuard configuration..."
    
    # Get configuration values
    local listen_port
    listen_port=$(get_config_value "vps.wireguard.listen_port" "51820")
    
    local vps_address
    vps_address=$(get_config_value "vps.wireguard.vps_address" "10.8.0.1/24")
    
    local private_key_path
    private_key_path=$(get_config_value "vps.wireguard.private_key_path" "/etc/wireguard/vps-private.key")
    
    local peers_dir
    peers_dir=$(get_config_value "vps.wireguard.peers_dir" "/etc/wireguard/peers")
    
    # Read private key
    local private_key
    if [[ -f "$private_key_path" ]]; then
        private_key=$(cat "$private_key_path")
    else
        log_error "VPS private key not found: $private_key_path"
        log "Run 03-wireguard-install.sh first to generate keys"
        exit 1
    fi
    
    # Generate WireGuard configuration using template
    local template_path="$SCRIPT_DIR/../templates/wg0.conf.template"
    local config_path="/etc/wireguard/wg0.conf"
    
    if [[ -f "$template_path" ]]; then
        substitute_template "$template_path" "$config_path" \
            "PRIVATE_KEY=$private_key" \
            "VPS_ADDRESS=$vps_address" \
            "LISTEN_PORT=$listen_port" \
            "PEERS_DIR=$peers_dir"
    else
        # Generate config directly if template doesn't exist
        log "Template not found, generating configuration directly..."
        generate_wg_config_direct "$config_path" "$private_key" "$vps_address" "$listen_port" "$peers_dir"
    fi
    
    # Set proper permissions
    chmod 600 "$config_path"
    
    log_success "WireGuard configuration generated: $config_path"
}

generate_wg_config_direct() {
    local config_path="$1"
    local private_key="$2"
    local vps_address="$3"
    local listen_port="$4"
    local peers_dir="$5"
    
    # Backup existing config
    backup_file "$config_path"
    
    # Generate base configuration
    cat > "$config_path" << EOF
# VPS WireGuard Configuration
# Generated by vps-proxy-hub setup

[Interface]
PrivateKey = $private_key
Address = $vps_address
ListenPort = $listen_port
SaveConfig = false

# Enable packet forwarding and NAT
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE

EOF
    
    # Add peers from configuration
    add_peers_to_config "$config_path" "$peers_dir"
}

add_peers_to_config() {
    local config_path="$1"
    local peers_dir="$2"
    
    log "Adding peers to WireGuard configuration..."
    
    # Get peers from config file
    if command -v yq &> /dev/null; then
        yq eval '.peers[] | .name' "$CONFIG_FILE" | while IFS= read -r peer_name; do
            add_peer_to_config "$config_path" "$peer_name" "$peers_dir"
        done
    else
        # Basic parsing for peer names
        grep -A 20 "^peers:" "$CONFIG_FILE" | grep "name:" | sed 's/.*name: *["'\'']*//' | sed 's/["'\'']*.*//' | while IFS= read -r peer_name; do
            if [[ -n "$peer_name" ]]; then
                add_peer_to_config "$config_path" "$peer_name" "$peers_dir"
            fi
        done
    fi
}

add_peer_to_config() {
    local config_path="$1"
    local peer_name="$2"
    local peers_dir="$3"
    
    if [[ -z "$peer_name" ]]; then
        return 0
    fi
    
    log "Processing peer: $peer_name"
    
    # Get peer configuration
    local peer_address peer_keepalive public_key_file
    
    if command -v yq &> /dev/null; then
        peer_address=$(yq eval ".peers[] | select(.name == \"$peer_name\") | .address" "$CONFIG_FILE")
        peer_keepalive=$(yq eval ".peers[] | select(.name == \"$peer_name\") | .keepalive" "$CONFIG_FILE")
    else
        # Basic parsing - find peer section and extract values
        peer_address=$(awk "/name:.*$peer_name/,/^[[:space:]]*-|^[^[:space:]]/ { if(/address:/) print \$2 }" "$CONFIG_FILE" | tr -d '"'"'" | head -1)
        peer_keepalive=$(awk "/name:.*$peer_name/,/^[[:space:]]*-|^[^[:space:]]/ { if(/keepalive:/) print \$2 }" "$CONFIG_FILE" | head -1)
    fi
    
    # Set defaults if not specified
    peer_keepalive=${peer_keepalive:-25}
    
    # Look for peer public key file
    public_key_file="$peers_dir/${peer_name}.pub"
    
    if [[ -f "$public_key_file" ]]; then
        local public_key
        public_key=$(cat "$public_key_file")
        
        # Add peer section to config
        cat >> "$config_path" << EOF

# Peer: $peer_name
[Peer]
PublicKey = $public_key
AllowedIPs = $peer_address
PersistentKeepalive = $peer_keepalive

EOF
        log "Added peer $peer_name to configuration"
    else
        log_warning "Public key not found for peer $peer_name: $public_key_file"
        log "Run home setup on the peer machine and copy the public key to this file"
        
        # Add placeholder peer section
        cat >> "$config_path" << EOF

# Peer: $peer_name (PUBLIC KEY NEEDED)
# [Peer]
# PublicKey = PASTE_PUBLIC_KEY_HERE
# AllowedIPs = $peer_address
# PersistentKeepalive = $peer_keepalive

EOF
    fi
}

setup_peer_management() {
    log "Setting up peer management..."
    
    local peers_dir
    peers_dir=$(get_config_value "vps.wireguard.peers_dir" "/etc/wireguard/peers")
    
    # Create peers directory if it doesn't exist
    ensure_directory "$peers_dir" "700"
    
    # Create helper script for adding peer public keys
    cat > /usr/local/bin/add-peer-key << 'SCRIPT_EOF'
#!/bin/bash
# Fixed Helper script to add a peer public key and regenerate WireGuard config

set -euo pipefail

if [[ $# -ne 2 ]]; then
    echo "Usage: $0 <peer-name> <public-key>"
    echo "Example: $0 dev-02 'LgvMuKX3vV3NGXurnIDclJUeaYw1zuG4dsuIkqYDghs='"
    exit 1
fi

PEER_NAME="$1"
PUBLIC_KEY="$2"
PEERS_DIR="/etc/wireguard/peers"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $*"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    log_error "This script must be run as root"
    exit 1
fi

# Create peers directory if it doesn't exist
mkdir -p "$PEERS_DIR"
chmod 700 "$PEERS_DIR"

# Save the public key
echo "$PUBLIC_KEY" > "$PEERS_DIR/${PEER_NAME}.pub"
chmod 600 "$PEERS_DIR/${PEER_NAME}.pub"

log_success "Added public key for peer: $PEER_NAME"

# Try to find config.yaml
CONFIG_PATHS=(
    "./config.yaml"
    "/root/vps-proxy-hub/config.yaml"
    "/opt/vps-proxy-hub/config.yaml"
    "$(pwd)/config.yaml"
    "$(dirname "$0")/../config.yaml"
)

CONFIG_FILE=""
for config_path in "${CONFIG_PATHS[@]}"; do
    if [[ -f "$config_path" ]]; then
        CONFIG_FILE="$config_path"
        break
    fi
done

if [[ -z "$CONFIG_FILE" ]]; then
    log_warning "Config file not found, using defaults"
else
    log "Using config file: $CONFIG_FILE"
fi

# Regenerate WireGuard configuration manually
log "Regenerating WireGuard configuration..."

# Get VPS configuration
VPS_PRIVATE_KEY_PATH="/etc/wireguard/vps-private.key"
VPS_ADDRESS="10.8.0.1/24"
LISTEN_PORT="51820"

# Try to get values from config if available
if [[ -n "$CONFIG_FILE" ]]; then
    if command -v yq &>/dev/null; then
        VPS_ADDRESS=$(yq eval '.vps.wireguard.vps_address' "$CONFIG_FILE" 2>/dev/null || echo "10.8.0.1/24")
        LISTEN_PORT=$(yq eval '.vps.wireguard.listen_port' "$CONFIG_FILE" 2>/dev/null || echo "51820")
        VPS_PRIVATE_KEY_PATH=$(yq eval '.vps.wireguard.private_key_path' "$CONFIG_FILE" 2>/dev/null || echo "/etc/wireguard/vps-private.key")
    else
        # Basic parsing
        VPS_ADDRESS=$(grep "vps_address:" "$CONFIG_FILE" | head -1 | sed 's/.*: *["'\'']*//' | sed 's/["'\'']*.*//' || echo "10.8.0.1/24")
        LISTEN_PORT=$(grep "listen_port:" "$CONFIG_FILE" | head -1 | sed 's/.*: *//' || echo "51820")
    fi
fi

if [[ ! -f "$VPS_PRIVATE_KEY_PATH" ]]; then
    log_error "VPS private key not found: $VPS_PRIVATE_KEY_PATH"
    log "Generate it with: wg genkey | sudo tee $VPS_PRIVATE_KEY_PATH | wg pubkey | sudo tee /etc/wireguard/vps-public.key"
    exit 1
fi

VPS_PRIVATE_KEY=$(cat "$VPS_PRIVATE_KEY_PATH")

# Backup existing config
if [[ -f /etc/wireguard/wg0.conf ]]; then
    cp /etc/wireguard/wg0.conf "/etc/wireguard/wg0.conf.backup.$(date +%Y%m%d_%H%M%S)"
    log "Backed up existing configuration"
fi

# Generate base configuration
cat > /etc/wireguard/wg0.conf << EOF
# VPS WireGuard Configuration
# Generated by add-peer-key script

[Interface]
PrivateKey = $VPS_PRIVATE_KEY
Address = $VPS_ADDRESS
ListenPort = $LISTEN_PORT
SaveConfig = false

# Enable packet forwarding and NAT
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE

EOF

# Add all peers from key files
PEERS_ADDED=0
for keyfile in "$PEERS_DIR"/*.pub; do
    if [[ -f "$keyfile" ]]; then
        PEER_NAME_LOCAL=$(basename "$keyfile" .pub)
        PUBLIC_KEY_LOCAL=$(cat "$keyfile")
        
        # Determine peer IP address
        PEER_ADDRESS=""
        
        if [[ -n "$CONFIG_FILE" ]] && command -v yq &>/dev/null; then
            # Try to get from config.yaml
            PEER_ADDRESS=$(yq eval ".peers[] | select(.name == \"$PEER_NAME_LOCAL\") | .address" "$CONFIG_FILE" 2>/dev/null || echo "")
            PEER_KEEPALIVE=$(yq eval ".peers[] | select(.name == \"$PEER_NAME_LOCAL\") | .keepalive" "$CONFIG_FILE" 2>/dev/null || echo "25")
        elif [[ -n "$CONFIG_FILE" ]]; then
            # Basic parsing
            PEER_ADDRESS=$(awk "/name:.*$PEER_NAME_LOCAL/,/^[[:space:]]*-[[:space:]]*name:|^[^[:space:]]/ {
                if (/address:/) {
                    gsub(/.*address:[[:space:]]*[\"']?/, \"\"); 
                    gsub(/[\"'].*/, \"\"); 
                    print \$0; 
                    exit
                }
            }" "$CONFIG_FILE" 2>/dev/null || echo "")
            PEER_KEEPALIVE="25"
        fi
        
        # If no address found in config, skip this peer
        if [[ -z "$PEER_ADDRESS" ]]; then
            log_error "No address found for peer $PEER_NAME_LOCAL in config.yaml"
            log_error "Please define this peer in your config.yaml file with an address"
            continue
        fi
        
        PEER_KEEPALIVE=${PEER_KEEPALIVE:-25}
        
        # Add peer section to config
        cat >> /etc/wireguard/wg0.conf << EOF

# Peer: $PEER_NAME_LOCAL
[Peer]
PublicKey = $PUBLIC_KEY_LOCAL
AllowedIPs = $PEER_ADDRESS
PersistentKeepalive = $PEER_KEEPALIVE

EOF
        log_success "Added peer: $PEER_NAME_LOCAL ($PEER_ADDRESS)"
        ((PEERS_ADDED++))
    fi
done

chmod 600 /etc/wireguard/wg0.conf

if [[ $PEERS_ADDED -gt 0 ]]; then
    log_success "Regenerated configuration with $PEERS_ADDED peer(s)"
    
    # Test configuration
    if ! wg-quick up wg0 &>/dev/null; then
        log_error "WireGuard configuration test failed"
        log "Check configuration manually: wg-quick up wg0 --dry-run"
        exit 1
    fi
    
    # Restart WireGuard
    log "Restarting WireGuard service..."
    if systemctl is-active --quiet wg-quick@wg0; then
        systemctl restart wg-quick@wg0
    else
        systemctl start wg-quick@wg0
    fi
    
    # Wait for service to be ready
    sleep 2
    
    if systemctl is-active --quiet wg-quick@wg0; then
        log_success "WireGuard service restarted successfully"
        
        echo ""
        log "Current WireGuard status:"
        wg show wg0 2>/dev/null || log_warning "Interface not ready yet"
    else
        log_error "WireGuard service failed to start"
        log "Check logs: journalctl -u wg-quick@wg0"
        exit 1
    fi
else
    log_warning "No peers were added to the configuration"
fi

log_success "Peer $PEER_NAME added successfully!"
SCRIPT_EOF
    
    chmod +x /usr/local/bin/add-peer-key
    log "Created peer management script: /usr/local/bin/add-peer-key"
}

enable_wireguard_service() {
    log "Enabling WireGuard service..."
    
    # Stop service if running
    if systemctl is-active --quiet wg-quick@wg0; then
        log "Stopping existing WireGuard service..."
        systemctl stop wg-quick@wg0
    fi
    
    # Enable and start WireGuard
    systemctl enable wg-quick@wg0
    systemctl start wg-quick@wg0
    
    # Wait for service to be ready
    wait_for_service "wg-quick@wg0"
    
    # Verify interface is up
    if ip link show wg0 &>/dev/null; then
        log_success "WireGuard interface wg0 is up"
    else
        log_error "WireGuard interface wg0 failed to start"
        log "Check logs: journalctl -u wg-quick@wg0"
        exit 1
    fi
}

display_connection_info() {
    log "WireGuard connection information:"
    
    # Show interface status
    if command -v wg &> /dev/null; then
        echo "--- WireGuard Status ---"
        wg show wg0 2>/dev/null || log_warning "WireGuard interface not ready"
    fi
    
    # Show VPS public key and endpoint info
    local public_key_path
    public_key_path=$(get_config_value "vps.wireguard.public_key_path" "/etc/wireguard/vps-public.key")
    
    local public_ip
    public_ip=$(get_config_value "vps.public_ip")
    
    local listen_port
    listen_port=$(get_config_value "vps.wireguard.listen_port" "51820")
    
    if [[ -f "$public_key_path" ]]; then
        local vps_public_key
        vps_public_key=$(cat "$public_key_path")
        
        echo ""
        echo "--- VPS Connection Information ---"
        echo "VPS Public Key: $vps_public_key"
        echo "VPS Endpoint: $public_ip:$listen_port"
        echo ""
        echo "Use this information when configuring home machine peers."
    fi
}

# Run main function
main "$@"