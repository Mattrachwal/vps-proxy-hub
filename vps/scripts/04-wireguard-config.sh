#!/bin/bash
# VPS Setup - WireGuard Configuration
# Generates WireGuard configuration from config.yaml and manages peer connections

set -euo pipefail

# Load utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../../shared/utils.sh"
source "$SCRIPT_DIR/../../shared/wireguard_utils.sh"

main() {
    log "Starting WireGuard configuration..."
    
    check_root
    check_config
    
    # Generate main WireGuard configuration
    generate_wg_config
    
    # Setup peer management
    setup_peer_management
    
    # Enable and start WireGuard service
    enable_wireguard_service
    
    # Display connection information
    display_connection_info
    
    log_success "WireGuard configuration completed"
}

generate_wg_config() {
    log "Generating WireGuard configuration..."
    
    # Get configuration values
    local listen_port
    listen_port=$(get_config_value "vps.wireguard.listen_port" "51820")
    
    local vps_address
    vps_address=$(get_config_value "vps.wireguard.vps_address" "10.8.0.1/24")
    
    local private_key_path
    private_key_path=$(get_config_value "vps.wireguard.private_key_path" "/etc/wireguard/vps-private.key")
    
    local peers_dir
    peers_dir=$(get_config_value "vps.wireguard.peers_dir" "/etc/wireguard/peers")
    
    # Read private key
    local private_key
    if [[ -f "$private_key_path" ]]; then
        private_key=$(cat "$private_key_path")
    else
        log_error "VPS private key not found: $private_key_path"
        log "Run 03-wireguard-install.sh first to generate keys"
        exit 1
    fi
    
    # Generate WireGuard configuration using template
    local template_path="$SCRIPT_DIR/../templates/wg0.conf.template"
    local config_path="/etc/wireguard/wg0.conf"
    
    if [[ -f "$template_path" ]]; then
        substitute_template "$template_path" "$config_path" \
            "PRIVATE_KEY=$private_key" \
            "VPS_ADDRESS=$vps_address" \
            "LISTEN_PORT=$listen_port" \
            "PEERS_DIR=$peers_dir"
    else
        # Generate config directly if template doesn't exist
        log "Template not found, generating configuration directly..."
        generate_wg_config_direct "$config_path" "$private_key" "$vps_address" "$listen_port" "$peers_dir"
    fi
    
    # Set proper permissions
    chmod 600 "$config_path"
    
    log_success "WireGuard configuration generated: $config_path"
}

generate_wg_config_direct() {
    local config_path="$1"
    local private_key="$2"
    local vps_address="$3"
    local listen_port="$4"
    local peers_dir="$5"
    
    # Backup existing config
    backup_file "$config_path"
    
    # Generate base configuration
    cat > "$config_path" << EOF
# VPS WireGuard Configuration
# Generated by vps-proxy-hub setup

[Interface]
PrivateKey = $private_key
Address = $vps_address
ListenPort = $listen_port
SaveConfig = false

# Enable packet forwarding and NAT
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o \$(ip route show default | awk '/default/ { print \$5 ; exit }') -j MASQUERADE

EOF
    
    # Add peers from configuration
    add_all_peers_to_config "$config_path" "$peers_dir"
}


setup_peer_management() {
    log "Ensuring peer directory exists..."
    local peers_dir
    peers_dir=$(get_config_value "vps.wireguard.peers_dir" "/etc/wireguard/peers")
    ensure_directory "$peers_dir" "700"
    log "Peer management: use ./tools/add-peer-key.sh to add keys and regenerate the config."
}

enable_wireguard_service() {
    log "Enabling WireGuard service..."
    
    # Stop service if running
    if systemctl is-active --quiet wg-quick@wg0; then
        log "Stopping existing WireGuard service..."
        systemctl stop wg-quick@wg0
    fi

    # Also bring down interface if it exists outside systemd control
    if ip link show wg0 &>/dev/null; then
        log "Bringing down existing wg0 interface..."
        wg-quick down wg0 || true
    fi
    
    # Enable and start WireGuard
    systemctl enable wg-quick@wg0
    systemctl start wg-quick@wg0
    
    # Wait for service to be ready
    wait_for_service "wg-quick@wg0"
    
    # Verify interface is up
    if ip link show wg0 &>/dev/null; then
        log_success "WireGuard interface wg0 is up"
    else
        log_error "WireGuard interface wg0 failed to start"
        log "Check logs: journalctl -u wg-quick@wg0"
        exit 1
    fi
}

display_connection_info() {
    log "WireGuard connection information:"
    
    # Show interface status
    if command -v wg &> /dev/null; then
        echo "--- WireGuard Status ---"
        wg show wg0 2>/dev/null || log_warning "WireGuard interface not ready"
    fi
    
    # Show VPS public key and endpoint info
    local public_key_path
    public_key_path=$(get_config_value "vps.wireguard.public_key_path" "/etc/wireguard/vps-public.key")
    
    local public_ip
    public_ip=$(get_config_value "vps.public_ip")
    
    local listen_port
    listen_port=$(get_config_value "vps.wireguard.listen_port" "51820")
    
    if [[ -f "$public_key_path" ]]; then
        local vps_public_key
        vps_public_key=$(cat "$public_key_path")
        
        echo ""
        echo "--- VPS Connection Information ---"
        echo "VPS Public Key: $vps_public_key"
        echo "VPS Endpoint: $public_ip:$listen_port"
        echo ""
        echo "Use this information when configuring home machine peers."
    fi
}

# Run main function
main "$@"